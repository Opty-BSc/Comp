%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "y.tab.h"
#include "postfix.h"
#include "minor.h"
/* Declarations */
extern int yyerror(char *s);
extern char *dupStr(const char *s);
extern FILE *yyout;
/* In File Declarations */
/* Variable Declarations */
static int lbl;
static char *externid[100];
static int ecnt;
static int chLoad;
static int ciclbl[10][2];
static int ciccnt = -1;
static int condlbl[10][2];
static int condcnt = -1;
static int aBytes;
/* Function Declarations */
static char *mkLbl(int lb);
static char *mkFid(char *s);
static void popExtern(char *id);
static void decExterns();
static int pos(char *id);
void doMain(int enter, Node *body);
void doFunc(int typ, char *id, int enter, Node *body);
void decVar(int typ, char *id, Node *sz, Node *val);
static void setPtr(Node *sz, Node *val, char *lb);
static void Int(int i);
static int IntS(Node *p);
static void Array(Node *p, Node *sz);
static void Str(char *s);
static void LitS(Node *p);
static void newIMMInt(int i);
static void newIMMStr(char *s);
static void newIMMLitS(Node *p);
static void doCall(int ext, char *id, int nB);
%}
%include "y.tab.h"
%term EXPRFI = ';' ECHO = '!' ALLOC = '#' INPUT = '?'
%term ADD = '+' SUB = '-' MUL = '*' DIV = '/' POW = '^' MOD = '%'
%term LT = '<' GT = '>' EQ = '=' NOT = '~' AND = '&' OR = '|'
%%

iBlock      : BLOCK(iSEQ, iLast)

iSEQ        : INSTRS(iSEQ, instruction)
iSEQ        : NIL

iLast       : RETURN(NIL)       1 { fprintf(yyout, pfLEAVE pfRET); }
iLast       : RETURN(rValue)    1 { fprintf(yyout, pfPOP pfLEAVE pfRET); }
iLast       : NIL

instruction : ALLOC(lValue, rValue)     1 { fprintf(yyout, pfTRASH, typBytes(PLACE(RIGHT_CHILD(p)))); }
instruction : EXPR(rValue, EXPRFI)      1 { fprintf(yyout, pfTRASH, typBytes(PLACE(LEFT_CHILD(p)))); }
instruction : EXPR(rValue, ECHO)        1 {
    doCall(1, isStr(LEFT_CHILD(p)) ? "prints" : "printi", typBytes(PLACE(LEFT_CHILD(p))));
}

%! For Start
instruction : FOR(iFor, STEP(DO(iForCond, iBlock), rValue)) 1 {
    fprintf(yyout, pfTRASH, typBytes(PLACE(RIGHT_CHILD(RIGHT_CHILD(p)))));
    fprintf(yyout, pfJMP, mkLbl(ciclbl[ciccnt][0]));
    fprintf(yyout, pfLABEL, mkLbl(ciclbl[ciccnt--][1]));
}
iFor        : rValue        1 {
    fprintf(yyout, pfTRASH, typBytes(PLACE(p)));
    fprintf(yyout, pfLABEL, mkLbl(ciclbl[++ciccnt][0] = ++lbl));
}
iForCond    : UNTIL(rValue) 1 {
    fprintf(yyout, pfJNZ, mkLbl(ciclbl[ciccnt][1] = ++lbl));
}
iLast       : REPEAT        1 {
    fprintf(yyout, pfJMP, mkLbl(ciclbl[ciccnt][0]));
}
iLast       : STOP          1 {
    fprintf(yyout, pfJMP, mkLbl(ciclbl[ciccnt][1]));
}
%! For End

%! Conditions Start
instruction : CONDITION(iIf, ELSES(iElifSEQ, iElse))    1 {
    fprintf(yyout, pfLABEL, mkLbl(condlbl[condcnt--][1]));
}
iIf         : IF(iCond, THEN(iBlock))   1 {
    fprintf(yyout, pfJMP, mkLbl(condlbl[condcnt][1] = ++lbl));
    fprintf(yyout, pfLABEL, mkLbl(condlbl[condcnt][0]));
}
iCond       : rValue                    1 {
    fprintf(yyout, pfJZ, mkLbl(condlbl[++condcnt][0] = ++lbl));
}
iElif       : ELIF(iCond, THEN(iBlock)) 1 {
    fprintf(yyout, pfJMP, mkLbl(condlbl[condcnt][1]));
    fprintf(yyout, pfLABEL, mkLbl(condlbl[condcnt][0]));
}
iElifSEQ    : ELIFS(iElifSEQ, iElif)
iElifSEQ    : NIL
iElse       : ELSE(iBlock)
iElse       : NIL
%! Conditions End

%! LValue Start
lValue      : ADDR(ID)             1 {
    fprintf(yyout, pfADDR, LEFT_CHILD(p)->value.s);
}
lValue      : LOCAL(ID)             1 {
    fprintf(yyout, pfLOCAL, pos(LEFT_CHILD(p)->value.s));
}
lValue      : LINDEX(lVec, rValue)  1 {
    chLoad = isStr(LEFT_CHILD(p));
    fprintf(yyout, pfIMM pfMUL pfADD, chLoad ? 1 : 4);
}
lVec        : ADDR(ID)              1 {
    fprintf(yyout, pfADDRV, LEFT_CHILD(p)->value.s);
}
lVec        : LOCAL(ID)             1 {
    fprintf(yyout, pfLOCV, pos(LEFT_CHILD(p)->value.s));
}
%! LValue End

%! Function Call Start
call        : CALL(FETCH(ID), aSEQ) 1 {
    doCall(0, LEFT_CHILD(LEFT_CHILD(p))->value.s, aBytes);
    aBytes = 0;
}
aSEQ        : ARGS(rValue, aSEQ)    1 {
    aBytes += typBytes(INFO(LEFT_CHILD(p)));
}
aSEQ        : NIL
%! Function Call End

lSEQ        : LITERALS(lSEQ, lSEQ)
lSEQ        : INT                       1
lSEQ        : CHAR                      1
lSEQ        : STR                       1
lSEQ        : NIL

rValue      : INT                       1 { newIMMInt(p->value.i); }
rValue      : CHAR                      1 { newIMMInt(p->value.i); }
rValue      : STR                       1 { newIMMStr(p->value.s); }
rValue      : lSEQ                      1 { newIMMLitS(p); }
rValue      : LOAD(lValue)              1 { fprintf(yyout, chLoad ? pfLDCHR : pfLOAD); chLoad = 0; }
rValue      : call                      1 {}
rValue      : RINDEX(call, rValue)      1 {}
rValue      : PRIORITY(rValue)          1 {}
rValue      : INPUT                     1 {}
rValue      : ADDR(lValue)              1 {}
rValue      : UMINUS(rValue)            1 { fprintf(yyout, pfNEG); }
rValue      : POW(rValue, rValue)       1 { doCall(1, "poweri", 8); }
rValue      : MUL(rValue, rValue)       1 { fprintf(yyout, pfMUL); }
rValue      : DIV(rValue, rValue)       1 { fprintf(yyout, pfDIV); }
rValue      : MOD(rValue, rValue)       1 { fprintf(yyout, pfMOD); }
rValue      : ADD(rValue, rValue)       1 { fprintf(yyout, pfADD); }
rValue      : SUB(rValue, rValue)       1 { fprintf(yyout, pfSUB); }
rValue      : LT(rValue, rValue)        1 { fprintf(yyout, pfLT); }
rValue      : GT(rValue, rValue)        1 { fprintf(yyout, pfGT); }
rValue      : LE(rValue, rValue)        1 { fprintf(yyout, pfLE); }
rValue      : GE(rValue, rValue)        1 { fprintf(yyout, pfGE); }
rValue      : NE(rValue, rValue)        1 { fprintf(yyout, pfNE); }
rValue      : EQ(rValue, rValue)        1 { fprintf(yyout, pfEQ); }
rValue      : OR(rValue, rValue)        1 { fprintf(yyout, pfOR); }
rValue      : AND(rValue, rValue)       1 { fprintf(yyout, pfAND); }
rValue      : NOT(rValue)               1 { fprintf(yyout, pfNOT); }
rValue      : ASSIGN(cpyrValue, lValue) 1 { fprintf(yyout, pfSTORE); }
cpyrValue   : rValue                    1 { fprintf(yyout, pfCOPY); }
%%

static char *mkLbl(int lb) {
    static char buf[20];
    sprintf(buf, "_i%d", lb);
    return buf;
}

static char *mkFid(char *s) {
    static char buf[80];
    sprintf(buf, "_%s", s);
    return buf;
}

static void popExtern(char *id) {
    
    for (int i = 0; i < ecnt; i++) {
        if (externid[i] && !strcmp(externid[i], id)) {
            free(externid[i]);
            externid[i] = NULL;
        }
    }
}

static void decExterns() {

    for (int i = 0; i < ecnt; i++) {
        if (externid[i]) {
            fprintf(yyout, pfEXTRN, externid[i]);
            free(externid[i]);
            externid[i] = NULL;
        }
    }
}

static int pos(char *id) {

    int **attrib = (int **)malloc(sizeof(int *));
    if (attrib == NULL) { yyerror("[Out of Memory]"); exit(2); }
    IDfind(id, (void **)attrib);
    int attr = **attrib;
    free(attrib);
    return attr;
}

void doMain(int enter, Node *body) {

    char *id = mkFid("main");

    fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, id, pfFUNC, id, enter);
    yyselect(RIGHT_CHILD(body));
    fprintf(yyout, pfIMM pfPOP pfLEAVE pfRET, 0);

    decExterns();
}

void doFunc(int typ, char *id, int enter, Node *body) {

    id = mkFid(id);
    popExtern(id);

    if (isForw(typ)) {
        externid[ecnt++] = dupStr(id);
        return;
    }
    if (isPubl(typ)) fprintf(yyout, pfGLOBL, id, pfFUNC);

    fprintf(yyout, pfTEXT pfALIGN pfLABEL pfENTER, id, enter);
    yyselect(RIGHT_CHILD(body));
    fprintf(yyout, pfLEAVE pfRET);
}

void decVar(int typ, char *id, Node *sz, Node *val) {

    popExtern(id);

    if (OP_LABEL(val) == NIL) {
        if (isForw(typ)) {
            externid[ecnt++] = dupStr(id);
            return;
        }
        if (OP_LABEL(sz) == NIL) {
            fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, id, typBytes(typ));
            return;
        }
    /* Initialized */
    } else if (isPubl(typ)) fprintf(yyout, pfGLOBL, id, pfFUNC);

    if (isConst(typ)) fprintf(yyout, pfRODATA pfALIGN pfLABEL, id);
    else fprintf(yyout, pfDATA pfALIGN pfLABEL, id);

    if (NAKED_TYPE(typ) == _INT) {
        Int(val->value.i);
        return;
    }
    char *lb = mkLbl(++lbl);
    fprintf(yyout, pfID, lb);
    setPtr(sz, val, lb);
}

static void setPtr(Node *sz, Node *val, char *lb) {

    switch (OP_LABEL(val)) {
        case NIL:
        case INT:
        case INTS:
            if (OP_LABEL(val) != NIL) {
                fprintf(yyout, pfDATA pfALIGN pfLABEL, lb);
                Array(val, sz);
                break;
            }
            fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, lb, sz->value.i);
            break;
        case STR:
            fprintf(yyout, pfRODATA pfALIGN pfLABEL, lb);
            Str(val->value.s);
            break;
        case LITERALS:
            fprintf(yyout, pfRODATA pfALIGN pfLABEL, lb);
            LitS(val);
            break;
    }
}

static void Int(int i) {
    
    fprintf(yyout, pfINTEGER, i);
}

static int IntS(Node *p) {

    if (OP_LABEL(p) == NIL) return 0;
    int cnt = IntS(LEFT_CHILD(p));

    fprintf(yyout, pfINTEGER, RIGHT_CHILD(p)->value.i);
    return ++cnt;
}

static void Array(Node *p, Node *sz) {

    int cnt = OP_LABEL(sz) != NIL ? sz->value.i : 0;

    switch (OP_LABEL(p)) {
        case INTS:
            cnt -= IntS(p);
            break;
        case INT:
            fprintf(yyout, pfINTEGER, p->value.i);
            cnt--;
            break;
    }
    while (cnt-- > 0) fprintf(yyout, pfINTEGER, 0);
}

static void Str(char *s) {

    do fprintf(yyout, pfCHAR, UC(*s));
    while (*s++);
}

static void LitS(Node *p) {
    static int nRec = 0;

    if (OP_LABEL(p) == NIL) return;
    nRec++;
    LitS(LEFT_CHILD(p));

    Node *val = RIGHT_CHILD(p);

    switch (OP_LABEL(val)) {
        case CHAR:
        case INT:
            fprintf(yyout, pfCHAR, UC(val->value.i));
            break;
        case STR:
            for (char *s = val->value.s; *s; s++) fprintf(yyout, pfCHAR, UC(*s));
            break;
    }
    if (!(--nRec)) fprintf(yyout, pfCHAR, '\0');
}

static void newIMMInt(int i) {

    fprintf(yyout, pfIMM, i);
}

static void newIMMStr(char *s) {

    char *lb = mkLbl(++lbl);

    fprintf(yyout, pfRODATA pfALIGN pfLABEL, lb);
    Str(s);
    fprintf(yyout, pfTEXT pfADDR, lb); 
}

static void newIMMLitS(Node *p) {

    char *lb = mkLbl(++lbl);

    fprintf(yyout, pfRODATA pfALIGN pfLABEL, lb);
    LitS(p);
    fprintf(yyout, pfTEXT pfADDR, lb);
}

static void doCall(int ext, char *id, int nB) {

    id = mkFid(id);
    if (ext) {
        popExtern(id);
        externid[ecnt++] = dupStr(id);
    }
    fprintf(yyout, pfCALL pfTRASH pfPUSH, id, nB);
}
