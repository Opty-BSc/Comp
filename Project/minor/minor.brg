%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "y.tab.h"
#include "postfix.h"
#include "minor.h"

char *dupStr(char *);
extern FILE *yyout;

static int lbl;
static char *externs[100];
static int ecnt;
static int chLoad;

/* Function Declarations */
static char *mkLbl(int);
static char *mkFid(char *);
static void Int(int);
static void Str(char *);
static int IntS(Node *);
static void Array(Node *, Node *);
static void LitS(Node *);
static void newIMMInt(int );
static void newIMMStr(char *);
static void newIMMLitS(Node *);
static void doCall(int, char *, int);
static void popExtern(char *);
static void decExterns();
void decVar(int, char *, Node *, Node *);
void doMain(int, Node *);
void doFunc(int, char *, int, Node *);
%}
%include "y.tab.h"
%term EXPRFI = ';' ECHO = '!' ALLOC = '#' INPUT = '?'
%term ADD = '+' SUB = '-' MUL = '*' DIV = '/' POW = '^' MOD = '%'
%term LESSER = '<' BIGGER = '>' EQ = '=' NOT = '~' AND = '&' OR = '|'
%%

body        : BODY(vSEQ, iBlock)        1 {}

vSEQ        : VARS(vSEQ, variable)      1 {}
vSEQ        : NIL                       1 {}

variable    : V_TYPE(type, V_ID(ID, size))  1 {}

type        : ARRAY                     1 {}
type        : NUMBER                    1 {}
type        : STRING                    1 {}

size        : V_DIM                     1 {}
size        : NIL                       1 {}

iBlock      : BLOCK(iSEQ, iLast)        1 {}

iSEQ        : INSTRS(iSEQ, instruction) 1 {}
iSEQ        : NIL                       1 {}

iLast       : REPEAT                    1 {}
iLast       : STOP                      1 {}
iLast       : RETURN(NIL)               1 {}
iLast       : RETURN(rValue)            1 {}
iLast       : NIL                       1 {}

instruction : EXPR(rValue, EXPRFI)      1 {}
instruction : EXPR(rValue, ECHO)        1 { doCall(1, isStr(LEFT_CHILD(p)) ? "prints" : "printi", pfWORD); }

instruction : ALLOC(lValue, rValue)     1 {}

instruction : CONDITION(IF(rValue, THEN(iBlock)), ELSES(iElifSEQ, iElse))   1 {}

instruction : FOR(rValue, UNTIL(rValue, STEP(rValue, DO(iBlock))))  1 {}

iElifSEQ    : ELIFS(iElifSEQ, ELIF(rValue, THEN(iBlock)))   1 {}

iElifSEQ    : NIL                       1 {}

iElse       : ELSE(iBlock)              1 {}
iElse       : NIL                       1 {}

lValue      : FETCH(ID)                 1 { fprintf(yyout, pfADDR, LEFT_CHILD(p)->value.s); }
lValue      : LINDEX(lVec, rValue)      1 { chLoad = isStr(LEFT_CHILD(p)); fprintf(yyout, pfIMM pfMUL pfADD, chLoad ? 1 : 4); }

lVec        : FETCH(ID)                 1 { fprintf(yyout, pfADDRV, LEFT_CHILD(p)->value.s); }

call        : CALL(FETCH(ID), aSEQ)     1 { doCall(0, LEFT_CHILD(LEFT_CHILD(p))->value.s, (int)(PLACE(RIGHT_CHILD(p)))); }

aSEQ        : ARGS(aSEQ, rValue)        1 { PLACE(p) = PLACE(LEFT_CHILD(p)) + (isInt(RIGHT_CHILD(p)) ? 4 : pfWORD); }
aSEQ        : NIL                       1 { PLACE(p) = 0; }

lSEQ        : LITERALS(lSEQ, lSEQ)
lSEQ        : INT                       1
lSEQ        : CHAR                      1
lSEQ        : STR                       1
lSEQ        : NIL

rValue      : INT                       1 { newIMMInt(p->value.i); }
rValue      : CHAR                      1 { newIMMInt(p->value.i); }
rValue      : STR                       1 { newIMMStr(p->value.s); }
rValue      : lSEQ                      1 { newIMMLitS(p); }
rValue      : LOAD(lValue)              1 { fprintf(yyout, chLoad ? pfLDCHR : pfLOAD); chLoad = 0; }
rValue      : call                      1 {}
rValue      : RINDEX(call, rValue)      1 {}
rValue      : PRIORITY(rValue)          1 {}
rValue      : INPUT                     1 {}
rValue      : ADDR(lValue)              1 {}
rValue      : UMINUS(rValue)            1 { fprintf(yyout, pfNEG); }
rValue      : POW(rValue, rValue)       1 { doCall(1, "poweri", 8); }
rValue      : MUL(rValue, rValue)       1 { fprintf(yyout, pfMUL); }
rValue      : DIV(rValue, rValue)       1 { fprintf(yyout, pfDIV); }
rValue      : MOD(rValue, rValue)       1 { fprintf(yyout, pfMOD); }
rValue      : ADD(rValue, rValue)       1 { fprintf(yyout, pfADD); }
rValue      : SUB(rValue, rValue)       1 { fprintf(yyout, pfSUB); }
rValue      : LESSER(rValue, rValue)    1 {}
rValue      : BIGGER(rValue, rValue)    1 {}
rValue      : LE(rValue, rValue)        1 {}
rValue      : GE(rValue, rValue)        1 {}
rValue      : NE(rValue, rValue)        1 {}
rValue      : EQ(rValue, rValue)        1 {}
rValue      : NOT(rValue)               1 {}
rValue      : AND(rValue, rValue)       1 {}
rValue      : OR(rValue, rValue)        1 {}
rValue      : ASSIGN(lValue, rValue)    1 {}
%%

static char *mkLbl(int lb) {
    static char buf[20];
    sprintf(buf, "_i%d", lb);
    return buf;
}

static char *mkFid(char *s) {
    static char buf[80];
    sprintf(buf, "_%s", s);
    return buf;
}

static void Int(int i) {
    
    fprintf(yyout, pfINTEGER, i);
}

static void Str(char *s) {

    do fprintf(yyout, pfCHAR, UC(*s));
    while (*s++);
}

static int IntS(Node *p) {

    if (OP_LABEL(p) == NIL) return 0;
    int cnt = IntS(LEFT_CHILD(p));

    fprintf(yyout, pfINTEGER, RIGHT_CHILD(p)->value.i);
    return ++cnt;
}

static void Array(Node *p, Node *sz) {

    int cnt = OP_LABEL(sz) != NIL ? sz->value.i : 0;

    switch (OP_LABEL(p)) {
        case INTS:
            cnt -= IntS(p);
            break;
        case INT:
            fprintf(yyout, pfINTEGER, p->value.i);
            cnt--;
            break;
    }

    if (cnt > 0) fprintf(yyout, pfBYTE, 4 * cnt);
}

static void LitS(Node *p) {

    static int nRec = 0;

    if (OP_LABEL(p) == NIL) return;
    nRec++;
    LitS(LEFT_CHILD(p));

    Node *val = RIGHT_CHILD(p);

    switch (OP_LABEL(val)) {
        case CHAR:
        case INT:
            fprintf(yyout, pfCHAR, UC(val->value.i));
            break;
        case STR:
            for (char *s = val->value.s; s[0]; s++)
                fprintf(yyout, pfCHAR, UC(s[0]));
            break;
    }

    if (!(--nRec)) fprintf(yyout, pfCHAR, '\0');
}

static void newIMMInt(int i) {

    fprintf(yyout, pfIMM, i);
}

static void newIMMStr(char *s) {

    char *lb = mkLbl(++lbl);

    fprintf(yyout, pfRODATA pfALIGN pfLABEL, lb);
    Str(s);
    fprintf(yyout, pfTEXT pfADDR, lb); 
}

static void newIMMLitS(Node *p) {

    char *lb = mkLbl(++lbl);

    fprintf(yyout, pfRODATA pfALIGN pfLABEL, lb);
    LitS(p);
    fprintf(yyout, pfTEXT pfADDR, lb); 
}

static void doCall(int ext, char *id, int nB) {

    if (ext) fprintf(yyout, pfEXTRN, mkFid(id));

    fprintf(yyout, pfCALL pfTRASH pfPUSH, mkFid(id), nB);
}

static void popExtern(char *id) {
    
    for (int i = 0; i < ecnt; i++) {
        if (externs[i] && !strcmp(externs[i], id)) {
            free(externs[i]);
            externs[i] = NULL;
        }
    }
}

static void decExterns() {

    for (int i = 0; i < ecnt; i++) {
        if (externs[i]) {
            fprintf(yyout, pfEXTRN, externs[i]);
            free(externs[i]);
            externs[i] = NULL;
        }
    }
}

void decVar(int typ, char *id, Node *sz, Node *val) {

    popExtern(id);

    if (OP_LABEL(val) != NIL) {
        /* Initialized */
        if (isPubl(typ)) fprintf(yyout, pfGLOBL, id, pfFUNC);

    } else {

        if (isForw(typ)) {
            externs[ecnt++] = dupStr(id);
            return;
        }
        if (OP_LABEL(sz) == NIL) {
            int nB = NAKED_TYPE(typ) == _INT ? 4 : pfWORD;

            fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE pfTEXT, id, nB);
            return;
        }
    }

    if (isConst(typ)) fprintf(yyout, pfRODATA);
    else fprintf(yyout, pfDATA);

    fprintf(yyout, pfALIGN pfLABEL, id);

    if (NAKED_TYPE(typ) == _INT) Int(val->value.i);
    else {
        /* Create Ptr */
        char *lb = mkLbl(++lbl);
        /* Ptr Init */
        switch (OP_LABEL(val)) {
            case NIL:
            case INT:
            case INTS:
                fprintf(yyout, pfID pfLABEL, lb, lb);
                Array(val, sz);
                break;
            case STR:
                fprintf(yyout, pfID pfRODATA pfLABEL, lb, lb);
                Str(val->value.s);
                break;
            case LITERALS:
                fprintf(yyout, pfID pfRODATA pfLABEL, lb, lb);
                LitS(val);
                break;
        }
    }
}

void doMain(int enter, Node *body) {

    char *id = mkFid("main");

    fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, id, pfFUNC, id, enter);
    yyselect(body);
    fprintf(yyout, pfIMM pfPOP pfLEAVE pfRET, 0);

    decExterns();
}

void doFunc(int typ, char *id, int enter, Node *p) {

    id = mkFid(id);
    popExtern(id);

    if (OP_LABEL(p) == DONE) {
        externs[ecnt++] = dupStr(id);
        return;
    }

    fprintf(yyout, pfTEXT pfALIGN);
    if (isPubl(typ)) fprintf(yyout, pfGLOBL, id, pfFUNC);

    fprintf(yyout, pfLABEL pfENTER, id, enter);
    yyselect(LEFT_CHILD(p));
    fprintf(yyout, pfLEAVE pfRET);
}
